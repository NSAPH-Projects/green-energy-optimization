---
title: "DistributedLag_group_control-demand"
author: "Arpita"
date: '2023-05-11'
output: html_document
---

```{r}
#install.packages("lubridate")
library(data.table)
library(lubridate)
library(dplyr)
library(tidyr)
```

```{r}
#devtools::install_github("danielmork/dlmtree", ref="development")
library(coda)
library(ggplot2)
library(ggpubr)
library(dlmtree)
library(splines)
library(readxl)
library(foreach)
#vignette("nested")
```

```{r}
countries <- c('CAL', 'CAR', 'CENT', 'FlA', 'MIDA', 'MIDW', 'NE', 'NW', 'SE', 'SW', 'TEN', 'TEX')
data_list <- list()
lag_data_list <- list()
lead_data_list <- list()
complete_list <- list()
for (i in (1:length(countries))){
  print(countries[i])
  data <- read_xlsx(paste("/n/dominici_lab/lab/fossil_fuel_energy/data/energy/Region_", countries[i], ".xlsx", sep=""), guess_max = 70000)
  #print(nrow(data))
  setDT(data)
  
  # Use filters after the shifted solar data is created
  #data <- data[!is.na(`NG: SUN`)]
  #data <- data[!which(`NG: SUN`<0)]
  #data <- data[which(`CO2 Emissions Generated`>0)]
  
  data[, date2 := as_date(`Local date`)]
  data[, dow := wday(date2)]
  data[, week := week(date2)]
  data[, month := month(date2)]
  data[, year := year(date2)]
  data[, demand := `D`]
  data[, index := 1:.N]
  
  # Make column names safe for use in formulas
  setnames(data, make.names(names(data)))
  #print(colnames(data))
  
  # Only consider data between during time period
  start_date = "2018-07-01"
  end_date = "2023-07-01"
  data <- data[data$date2 >= start_date & data$date2 < end_date, ]
  
  #convert negative solar values and zero CO2 emissions as NA. 
  data$NG..SUN = replace(data$NG..SUN , which(data$NG..SUN  < 0), 0)
  data$NG..SUN = replace(data$NG..SUN , which(data$CO2.Emissions.Generated <= 0), NA)

  # Create lagged data
  lags <- 12
  lag_dat <- as.matrix(data[, shift(NG..SUN, 0:lags, type = "lag")])
  #lead_dat <- as.matrix(data[, shift(NG..SUN, 10:1, type = "lead")])
  #lag_dat <- cbind(lead_dat, lag_dat)
  # data[, demand_ma10 := rollmean(demand, k = 10)] -- CHECK! 
  # Complete data rows

  data_list[[i]]<-data #Note: this data may contain NA values
  lag_data_list[[i]]<- lag_dat #Note: this data may contain NA values
  #lead_data_list[[i]]<-lead_dat
  complete_list[[i]] <- which(complete.cases(lag_dat) & 
                            complete.cases(data[, .(CO2.Emissions.Generated, demand)]))

}
```


```{r}
# Individual Nonlinear lagged model

mlist <- lapply(countries, function(x) list())
gr <- lapply(countries, function(x) list())
names(mlist) <- countries
names(gr) <- countries
restarts <- 5


# Iterate through regions, assess convergence, increase # trees
for (i in 1:length(countries)) {
  for (ntrees in c(20, 40, 80)) {
    cat(countries[i], "ntrees =", ntrees, "\n")
    data <- data_list[[i]]
    complete <- complete_list[[i]]
    lag_dat <- lag_data_list[[i]]
    splits <- seq(quantile(lag_dat[complete,], .05), quantile(lag_dat[complete,], .95), length.out = 10) #5%and 95% percentile
    
    # Run monotone-TDLNM
    model_run <-
      foreach(m = 1:restarts,
              .errorhandling = "remove",
              .packages = c("dlmtree", "data.table", "splines"),
              .export = c("data", "complete", "splits", "lag_dat", "g0", "s0"),
              .verbose = F) %do%
      {
        set.seed(m)
        tdlnm(I(-1*CO2.Emissions.Generated) ~
                ns(index, df = 10) +
                ns(Hour, df = 5) +
                demand,
              data[complete],
              exposure.data = lag_dat[complete,],
              exposure.splits = splits,
              monotone = T, shrinkage = F, 
              monotone.sigma = diag(lags + 1) * 2.701^2,
              time.split.prob = lags:1,
              n.trees = ntrees,
              #n.burn=10000, n.iter=5000,
              verbose = F)
      }
    
    # Check convergence
    s <- lapply(model_run, summary, cenval = median(data_list[[i]][NG..SUN>0, NG..SUN]),
                mcmc = TRUE, verbose = FALSE)
    mcmc_mtdlnm <- do.call(mcmc.list, lapply(1:length(model_run), function(i) {
      d <- as.data.frame.table(s[[i]]$dlm_mcmc)
      setDT(d)
      mcmc(dcast(d, Var3 ~ Var1 + Var2, value.var = "Freq")[, Var3 := NULL][])
    }))
    gr_test <- gelman.diag(mcmc_mtdlnm, transform = F, autoburnin = F, multivariate = F)
    cat(" GR =", median(gr_test$psrf[, 1]), "\n")
    
    if (is.null(gr[[countries[i]]]$psrf) || (median(gr_test$psrf[, 1]) < median(gr[[countries[i]]]$psrf[, 1]))) {
      mlist[[countries[i]]] <- model_run
      gr[[countries[i]]] <- gr_test
    }
  }
  dm_mlist<- mlist[[countries[i]]]
  save(dm_mlist, file=paste("mlist_",countries[i],".Rda",sep=""))
  dm<- combine.models(mlist[[countries[i]]])
  save(dm, file=paste("dm_mod_",countries[i],".Rda",sep=""))
  ntrees_best <- gr[[countries[i]]]
  save(ntrees_best, file=paste("gr_",countries[i],".Rda",sep=""))
}
```

```{r}
# Basic model results (load each save model first)
load(paste("mlist_",countries[i],".Rda",sep=""))
dm <- combine.models(dm_mlist)
s_dm <- summary(dm, cenval = median(data_list[[i]][NG..SUN>0, NG..SUN]), 
                mcmc = T)
plot(s_dm)
plot(s_dm, "slice", time = 1)
plot(s_dm, "cumulative")
plot(s_dm$splitProb, type = 'l', ylim = c(0, 1)); abline(h = 0.95)

{plot(s_dm$dlm_mcmc[1, 9, ], type = 'l', ylim = c(0, max(s_dm$dlm_mcmc[1, 9, ])))
    for (j in 2:9)
        lines(s_dm$dlm_mcmc[j, 9, ], col = j)
    for (j in 1:9)
        abline(h = mean(s_dm$dlm_mcmc[j, 9, ]), col = j)
}
```

```{r}
for (i in (1:length(countries))){
  data <- data_list[[i]]
  complete <- complete_list[[i]]
  lag_dat <- lag_data_list[[i]]
  #set.seed(6757+i)
  #g0 <- rep(-1.604, lags + 1) # prior prob .01-.8
  #g0[1:5] <- 2.991 # prior prob 0.8-0.99 middle 95%
  #s0 <- diag(lags + 1) * 1.526^2
  #for (s in 1:5)
  #  s0[s, s] <- 0.819^2
  #dlnm_mod_list[[i]]
 mlist<- lapply(1:5, function(j) {
                                set.seed(6757+abs(i-2)+2+j)
                                tdlnm(I(-1*CO2.Emissions.Generated) ~ ns(index, df = 10) +  ns(Hour, df=5) + demand,  #factor(hour)<-  
                            #ns(index, df = 24) + ns(index, df = 4) * factor(Hour)
                                              data[complete],
                                              exposure.data = lag_dat[complete,],
                                              exposure.splits = seq(quantile(lag_dat[complete,], .05), quantile(lag_dat[complete,], .95), length.out = 10), #5%and 95% percentile
                                              #n.burn = 500, n.iter = 1000,
                                              monotone = T,
                                              time.split.prob = rep(c(10, 3), c(4, 19)),
                                              monotone.time.kappa = 2
                                              #monotone.gamma0 = g0,
                                              #monotone.sigma = s0#,
                                              #n.burn=2000, n.iter=2000
                                              )
    #save(dm, file=paste("dlnm_mlist_June30_f_23hrs_",countries[i],j,".Rda",sep=""))
  })
  
  dm<- combine.models(mlist)
  #dm<-dlnm_mod_list[[i]]
  save(dm, file=paste("dlnm_mod_June30_f_23hrs_",countries[i],".Rda",sep=""))
  #save(dlnm_mod_list,file="dlnm_mod_list.Rda")
}

```


```{r}
#linear model
library(ggplot2)
library(scico)
library(dlmtree)
library(plotrix)
library(latex2exp)
library(mgcv)
for (i in 1:length(countries)){
  data <- data_list[[i]]
  complete <- complete_list[[i]]
  lag_dat <- lag_data_list[[i]]
  #m_linear <- lm(I(-1*CO2.Emissions.Generated) ~ ns(index, df = 10) +  ns(Hour, df=5) + demand + lag_dat[complete,], data[complete]) #or exposure.se = 10000
  #AIC(m_linear)
  
  m_smooth <- gam(formula=I(-1*CO2.Emissions.Generated) ~ ns(index, df = 10) +  ns(Hour, df=5) + demand + s(lag_dat[complete,1]), data=data[complete,])
  plot(m_smooth, xlab = "solar", 
           ylab = "s(solar)", main = paste(countries[i], sep=""))
  
  #m_smooth <- gam(formula=I(-1*CO2.Emissions.Generated) ~ ns(index, df = 10) +  ns(Hour, df=5) + demand + lag_dat[complete,], data=data[complete,])
  #AIC(m_smooth)
  
  #compare with treed model
  load(paste("dm_mod_", countries[i], ".Rda", sep="")) #Treed model
  s_dm = summary(dm, pred.at = median(data$NG..SUN, na.rm = T)+1, cenval = median(data$NG..SUN, na.rm = T), verbose = FALSE) #estimates of treed model with median+1 vs median
  res=rbind(m_linear$coefficients[18:30], s_dm$matfit)
  x=0:12
  y1=unlist(res[1,])
  y2=unlist(res[2,])
  
  p<-matplot(x, cbind(y1, y2), type = "l", lty = 1, 
           col = c("red", "blue"), xlab = "Lags", 
           ylab = "CO2", main = paste(countries[i], sep=""))
        legend("topright", legend = c("Linear", "Treed"), 
          col = c("red", "blue"), 
          lty = 1)

  png(paste(countries[i], "_lm.png", sep=""), width=800, height=500)
  print(p)
  dev.off()
}

```


```{r}
#save(dlnm_mod_list,file="dlnm_mod_list.Rda")
```

```{r}
folder ="June30"

for (i in (1:length(countries))){
  #load(paste("/n/dominici_lab/lab/fossil_fuel_energy/dan_solar_dlm/save_",folder,"/region_",countries[i],"_Aug29.rda",sep=""))
  load(paste("dlnm_mod_June30_f_", countries[i], ".Rda",sep=""))
  
  jpeg(paste("qqplot_",folder,"_", countries[i],".jpg", sep=""))
  p<- qqnorm(scale(dm$Y - dm$Yhat)); abline(0, 1)
  print(p)
  dev.off()

  jpeg(paste("difference_",folder,"_",countries[i],".jpg", sep=""))
  p<- plot(dm$Y, dm$Yhat-dm$Y)
  print(p)
  dev.off()
}
```



```{r}

for (i in (1:length(countries))){
  print(paste("country: ", countries[i], sep=""))
  #dlnm_mod <- dlnm_mod_list[[i]]
  load(paste("dlnm_mod_June12_",countries[i],".Rda",sep=""))
  
  s_dlnm_mod <- summary(dm, cenval = 0, conf.level = .9)
  jpeg(paste("lineplot_June12_",countries[i],".jpg", sep=""))
  plot(0:lags, s_dlnm_mod$splitProb, type = 'l', ylim = 0:1,
       main = paste(countries[i], " Region", sep=""),
       xlab = "lag (+)", ylab = "Prob effect"); abline(h = 0.95, lty = 2)
  dev.off()
}
```

```{r}
for (i in (1:length(countries))){
  #dlnm_mod <- dlnm_mod_list[[i]]
    load(paste("dlnm_mod_June12_",countries[i],".Rda",sep=""))
    s_dlnm_mod <- summary(dm, cenval = 0, conf.level = .9)
    jpeg(paste("heatmap_June12_",countries[i],".jpg", sep=""))
    plot(s_dlnm_mod, start.time = 0,
       xlab = "Lag hour",
       ylab = "Solar generation",
       flab = "Decreased CO2",
       main = paste(countries[i], " Region", sep="")) + scale_fill_viridis_c(limits=c(-1000, 6000)) # c(0,720)
    dev.off()
}

```

```{r}
y_upper_list<- c(6000, 6000, 500, 20000, 40000, 1500, 75, 12000)
y_lower_list<- c(-200, -200, -200, -200, -200, -200, -75, -200)
for (i in (1:length(countries))){
  #dlnm_mod <- dlnm_mod_list[[i]]
  load(paste("dlnm_mod_May30_",countries[i],".Rda",sep=""))
  
  s_dlnm_mod <- summary(dm, cenval = 0, conf.level = .9)
  jpeg(paste("continuous_May30_",countries[i],".jpg", sep="")) 
  p2 <- plot(s_dlnm_mod, "slice", time = 0, start.time = 0,
             xlab = "Solar generation", ylab = "Decrease in CO2 generation",
             main = "Same time") + scale_y_continuous(limits=c(y_lower_list[i],y_upper_list[i]))
  p3 <- plot(s_dlnm_mod, "slice", time = 1, start.time = 0,
             xlab = "", ylab = "", 
             main = "1 hour lag") + scale_y_continuous(limits=c(y_lower_list[i],y_upper_list[i]))
  p4 <- plot(s_dlnm_mod, "slice", time = 2, start.time = 0,
             xlab = "", ylab = "", 
             main = "2 hours lag") + scale_y_continuous(limits=c(y_lower_list[i],y_upper_list[i]))
  p5 <- plot(s_dlnm_mod, "slice", time = 3, start.time = 0,
             xlab = "", ylab = "", 
             main = "3 hours lag") + scale_y_continuous(limits=c(y_lower_list[i],y_upper_list[i]))
#  p6 <- plot(s_dlnm_mod, "slice", time = 8, start.time = 0,
#             xlab = "", ylab = "", 
#             main = "8 hours lag") + scale_y_continuous(limits=c(y_lower_list[i],y_upper_list[i]))
#  p7 <- plot(s_dlnm_mod, "slice", time = 12, start.time = 0,
#             xlab = "", ylab = "", 
#             main = "12 hours lag") + scale_y_continuous(limits=c(y_lower_list[i],y_upper_list[i]))
  ggarrange(p2, p3, p4,p5)#,p6,p7)
  dev.off()
}
```


```{r}
#Year-wise analysis
year_wise_analysis <- function(country, start_date, end_date){
  #setwd("/n/dominici_lab/lab/fossil_fuel_energy/data/")
  data <- read_xlsx(paste("/n/dominici_lab/lab/fossil_fuel_energy/data/energy/Region_", country, ".xlsx", sep=""), guess_max = 50000)
  setDT(data)
  data <- data[!is.na(`NG: SUN`)]
  data <- data[!which(`NG: SUN`<0)]
  data <- data[which(`CO2 Emissions Generated`>=0)]
  data[, date2 := as_date(`Local date`)]
  data[, dow := wday(date2)]
  data[, week := week(date2)]
  data[, month := month(date2)]
  data[, year := year(date2)]
  data[, demand := `D`]
  data[, index := 1:.N]
  
  #Extract rows from a particular year
  data <- data[data$date >= start_date & data$date < end_date, ]
  
  # Make column names safe for use in formulas
  setnames(data, make.names(names(data)))
  #print(colnames(data))
  
  
  # Create lagged data
  lags <- 12
  lag_dat <- as.matrix(data[, shift(NG..SUN, 0:12, type = "lag")])
  #lead_dat <- as.matrix(data[, shift(NG..SUN, 10:1, type = "lead")])
  #lag_dat <- cbind(lead_dat, lag_dat)
  # data[, demand_ma10 := rollmean(demand, k = 10)] -- CHECK! 
  # Complete data rows
  
  complete <- which(complete.cases(lag_dat) & 
                            complete.cases(data[, .(CO2.Emissions.Generated, demand)]))
  dlnm_mod_year_wise <- combine.models(lapply(1:5, function(j) {
                                    tdlnm(I(-1*CO2.Emissions.Generated) ~ ns(index, df = 10) + ns(index, df=10)* ns(Hour, df = 5) + demand,       
                                                  data[complete],
                                                  exposure.data = lag_dat[complete,],
                                                  exposure.splits = seq(quantile(lag_dat[complete,], .05), quantile(lag_dat[complete,], .95), length.out = 10), #5%and 95% percentile
                                                  #n.burn = 500, n.iter = 1000,
                                                  monotone = T,
                                                  time.split.prob = rep(c(10, 3), c(6, 19)))
      }))
    save(dlnm_mod_year_wise,file=paste("dlnm_mod_",paste(country, start_date, end_date, sep="_"),".Rda", sep=""))
}
```

```{r}
country_list = c("CAL", "SW", "MIDW")
timestamps = c("2018-07-01", "2020-12-31", "2023-05-22")
for (i in 1:length(country_list)){
  for (j in 1:(length(timestamps)-1)){
    year_wise_analysis(country_list[i], timestamps[j], timestamps[j+1])
  }
}
```

```{r}
country_list = c("CAL")
years = c("2018", "2019", "2020", "2021", "2022", "2023")
for (i in 1:length(country_list)){
  for (j in 1:length(years)){
    country = country_list[i]
    year =years[j] 
    
    load(paste("dlnm_mod_",paste(country, start_date, end_date, sep="_"),".Rda", sep=""))
    s_dlnm_mod <- summary(dlnm_mod_year_wise, cenval = 0, conf.level = .9)
    
    #lineplot 
    jpeg(paste("lineplot_year_wise_",paste(country, start_date, end_date, sep="_"),".jpg", sep=""))
    plot(0:lags, s_dlnm_mod$splitProb, type = 'l', ylim = 0:1,
         main = paste(base, other, sep="_"),
         xlab = "lag (+)", ylab = "Prob effect"); abline(h = 0.95, lty = 2)
    dev.off()
    
    #heatmap
    jpeg(paste("heatmap_year_wise_",paste(country, start_date, end_date, sep="_"),".jpg", sep=""))
    plot(s_dlnm_mod, start.time = 0,
       xlab = "Lag hour",
       ylab = "Solar generation",
       flab = "Decreased CO2",
       main = paste(country, ": (", start_date, " to ", end_date, ")", sep=""))
    dev.off()
  }
}
```


```{r}
# Individual Nonlinear lagged model for neighboring effect analysis

#One country's CO2 reduction based on the "base" country
countries <- c('CAL', 'CAR', 'CENT', 'FlA', 'MIDA', 'MIDW', 'NE', 'NW', 'SE', 'SW', 'TEN', 'TEX')
base_countries =c(1,1,2,2,3,3,3,3,5,5,5,6,6,8,8,9,9,9,9,10,11,11,11,12)
other_countries =c(10,8,5,9,6,8,10,12,2,6,11,9,11,1,10,2,4,6,11,1,2,5,9,3)

combo_list<-list()
for (i in (1:length(base_countries))){
    base_country <- countries[base_countries[i]]
    other_country <- countries[other_countries[i]]
    combo_list<- append(combo_list, paste(base_country, other_country, sep="-"))
}
combo_list<- unlist(combo_list)

mlist <- lapply(combo_list, function(x) list())
gr <- lapply(combo_list, function(x) list())
names(mlist) <- combo_list
names(gr) <- combo_list
restarts <- 5
```

```{r}
run_analysis <- function(combo, base, other, i){
    print(paste("base=",base, ", other=", other, sep=""))
    data <- combo
    setDT(data)
    #print(colnames(data))
    #data <- data[!is.na(`NG: SUN`)]
    #print(nrow(data))
    #data <- data[!which(`NG: SUN`<0)]
    #print(nrow(data))
    #data <- data[which(`CO2 Emissions Generated`>=0)]
    #print(nrow(data))

    data[, date2 := as_date(`Local.date`)]
    data[, dow := wday(date2)]
    data[, week := week(date2)]
    data[, month := month(date2)]
    data[, year := year(date2)]
    data[, demand := `D`]
    data[, index := 1:.N]
    
    # Make column names safe for use in formulas
    setnames(data, make.names(names(data)))
    #print(colnames(data))
    
    
    # Create lagged data
    lags <- 12
    lag_dat <- as.matrix(data[, shift(NG..SUN, 0:lags, type = "lag")])
    #lead_dat <- as.matrix(data[, shift(NG..SUN, 10:1, type = "lead")])
    #lag_dat <- cbind(lead_dat, lag_dat)
    
    complete<- which(complete.cases(lag_dat) & 
                                complete.cases(data[, .(CO2.Emissions.Generated, demand, NG..SUN, NG..SUN.y)]))
    
    
    for (ntrees in c(20, 40)) {
    cat(combo_list[i], "ntrees =", ntrees, "\n")
    splits <- seq(quantile(lag_dat[complete,], .05), quantile(lag_dat[complete,], .95), length.out = 10) #5%and 95% percentile
    
    # Run monotone-TDLNM
    model_run <-
      foreach(m = 1:restarts,
              .errorhandling = "remove",
              .packages = c("dlmtree", "data.table", "splines"),
              .export = c("data", "complete", "splits", "lag_dat", "g0", "s0"),
              .verbose = F) %do%
      {
        set.seed(m)
        tdlnm(I(-1*CO2.Emissions.Generated) ~
                ns(index, df = 10) +
                ns(Hour, df = 5) +
                demand,
              data[complete],
              exposure.data = lag_dat[complete,],
              exposure.splits = splits,
              monotone = T, shrinkage = F, 
              monotone.sigma = diag(lags + 1) * 2.701^2,
              time.split.prob = lags:1,
              n.trees = ntrees,
              #n.burn=10000, n.iter=5000,
              verbose = F)
      }
    
    # Check convergence
    s <- lapply(model_run, summary, cenval = median(data[NG..SUN>0, NG..SUN]),
                mcmc = TRUE, verbose = FALSE)
    mcmc_mtdlnm <- do.call(mcmc.list, lapply(1:length(model_run), function(i) {
      d <- as.data.frame.table(s[[i]]$dlm_mcmc)
      setDT(d)
      mcmc(dcast(d, Var3 ~ Var1 + Var2, value.var = "Freq")[, Var3 := NULL][])
    }))
    gr_test <- gelman.diag(mcmc_mtdlnm, transform = F, autoburnin = F, multivariate = F)
    cat(" GR =", median(gr_test$psrf[, 1]), "\n")
    
    if (is.null(gr[[combo_list[i]]]$psrf) || (median(gr_test$psrf[, 1]) < median(gr[[combo_list[i]]]$psrf[, 1]))) {
      mlist[[combo_list[i]]] <- model_run
      gr[[combo_list[i]]] <- gr_test
    }
  }
  dm_mlist<- mlist[[combo_list[i]]]
  save(dm_mlist, file=paste("mlist_",combo_list[i],".Rda",sep=""))
  dm<- combine.models(mlist[[combo_list[i]]])
  save(dm, file=paste("dm_mod_",combo_list[i],".Rda",sep=""))
  ntrees_best <- gr[[combo_list[i]]]
  save(ntrees_best, file=paste("gr_",combo_list[i],".Rda",sep=""))
}
```


```{r}
generate_plots<- function(base, other, k){
  file_name = paste("dlnm_mod_directed_", paste(base, other, sep="_"),".Rda", sep="")
  if(!file.exists(file_name)){
    return (NULL)
  }
    load(file_name)
    s_dlnm_mod <- summary(dlnm_mod_directed, cenval = 0, conf.level = .9)
    
    #lineplot 
    jpeg(paste("lineplot_directed_May30_",paste(base, other, sep="_"),".jpg", sep=""))
    plot(0:lags, s_dlnm_mod$splitProb, type = 'l', ylim = 0:1,
         main = paste(base, other, sep="_"),
         xlab = "lag (+)", ylab = "Prob effect"); abline(h = 0.95, lty = 2)
    dev.off()
    
    #heatmap
    jpeg(paste("heatmap_directed_May30_",paste(base, other, sep="_"),".jpg", sep=""))
    plot(s_dlnm_mod, start.time = 0,
       xlab = "Lag hour",
       ylab = "Solar generation",
       flab = "Decreased CO2",
       main = paste(base, other, sep="_"))
    dev.off()
    
    #lagged plots
    jpeg(paste("continuous_directed_May30_",paste(base, other, sep="_"),".jpg", sep=""))
    p2 <- plot(s_dlnm_mod, "slice", time = 0, start.time = 0,
               xlab = "Solar generation", ylab = "Decrease in CO2 generation",
               main = "Same time") + scale_y_continuous(limits=c(y_lower_list[k],y_upper_list[k]))
    p3 <- plot(s_dlnm_mod, "slice", time = 1, start.time = 0,
               xlab = "", ylab = "", 
               main = "1 hour lag") + scale_y_continuous(limits=c(y_lower_list[k],y_upper_list[k]))
    p4 <- plot(s_dlnm_mod, "slice", time = 3, start.time = 0,
               xlab = "", ylab = "", 
               main = "3 hours lag") + scale_y_continuous(limits=c(y_lower_list[k],y_upper_list[k]))
    p5 <- plot(s_dlnm_mod, "slice", time = 5, start.time = 0,
               xlab = "", ylab = "", 
               main = "5 hours lag") + scale_y_continuous(limits=c(y_lower_list[k],y_upper_list[k]))
    p6 <- plot(s_dlnm_mod, "slice", time = 8, start.time = 0,
               xlab = "", ylab = "", 
               main = "8 hours lag") + scale_y_continuous(limits=c(y_lower_list[k],y_upper_list[k]))
    p7 <- plot(s_dlnm_mod, "slice", time = 12, start.time = 0,
               xlab = "", ylab = "", 
               main = "12 hours lag") + scale_y_continuous(limits=c(y_lower_list[k],y_upper_list[k]))
    ggarrange(p2, p3, p4, p5, p6, p7)
    dev.off()
}
  #CAL_CAR = [-200, 8000]

```


```{r}
for (i in (1:length(combo_list))){
  {
    {
    
      base_country <- countries[base_countries[i]]
      other_country <- countries[other_countries[i]]
      
      print(combo_list[i])
      
      #Load data of base_country
      d<- data_list[[base_countries[i]]]
      
      #Only keep the desired number of columns
      d <- d[, c("UTC.time", "NG..SUN")]
      
      #Create one merged file
      d<-merge(d, data_list[[other_countries[i]]], by=c("UTC.time"))
      print(colnames(d))
      #d$D<- d$D.y
      d$NG..SUN<- d$NG..SUN.x 
      #d$CO2.Emissions.Generated <- d$CO2.Emissions.Generated.y
      d <- d[, c("Local.date", "Hour", "D", "NG..SUN", "NG..SUN.y", "CO2.Emissions.Generated")]
      
      #Run analysis
      run_analysis(combo = d, base = base_country, other = other_country, i=i)
    }
  }
  
}


#For other country, adjust the trade exchange value
#d <- data_list[[2]]

#d<- d %>% mutate_at(c(paste(other_country)), ~replace_na(.,0))
#d$D_new <- d$D_new + d[[other_country]]
```

```{r}
y_upper_list = c(1000, 20000)
y_lower_list = c(-200, -200)
k=1
for (i in (1:length(countries))){
  for(j in (1:length(countries))){
    if(i!=j){
      base <- countries[i]
      other <- countries[j]
      print(paste(base, other, sep="_"))
      generate_plots(base, other, k)
      
    }
  }
}
```

